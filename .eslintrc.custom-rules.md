# Custom ESLint Rules & Project Patterns

## Overview
This document outlines custom linting rules and coding patterns specific to this project.

## Project-Specific Patterns

### 1. Error Handling
**Rule**: All async functions must have proper error handling
```typescript
// ❌ BAD
async function fetchData() {
  const response = await fetch('/api/data');
  return response.json();
}

// ✅ GOOD
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    logError('fetchData', error);
    throw error;
  }
}
```

### 2. Supabase Query Safety
**Rule**: Always use safe query patterns with proper null checks
```typescript
// ❌ BAD
const { data } = await supabase.from('users').select('*').single();
return data.email; // Can crash if data is null

// ✅ GOOD
const { data, error } = await supabase.from('users').select('*').maybeSingle();
if (error) {
  logError('fetchUser', error);
  return null;
}
return data?.email ?? null;
```

### 3. Numeric Safety
**Rule**: Always use utility functions for numeric operations
```typescript
// ❌ BAD
const total = warranty.base_price + warranty.options_price;

// ✅ GOOD
import { safeAdd, safeNumber } from '@/lib/numeric-utils';
const total = safeAdd(
  safeNumber(warranty.base_price, 0),
  safeNumber(warranty.options_price, 0)
);
```

### 4. Component Props
**Rule**: Always define explicit types for component props
```typescript
// ❌ BAD
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// ✅ GOOD
interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
  variant?: 'primary' | 'secondary';
}

function Button({ onClick, children, variant = 'primary' }: ButtonProps) {
  return <button onClick={onClick} className={variant}>{children}</button>;
}
```

### 5. Context Usage
**Rule**: Always provide proper error messages for missing context
```typescript
// ❌ BAD
const context = useContext(AuthContext);
return context.user;

// ✅ GOOD
const context = useContext(AuthContext);
if (!context) {
  throw new Error('useAuth must be used within AuthProvider');
}
return context.user;
```

### 6. Form State Management
**Rule**: Use controlled components with proper validation
```typescript
// ❌ BAD
<input name="email" />

// ✅ GOOD
const [email, setEmail] = useState('');
const [emailError, setEmailError] = useState('');

const validateEmail = (value: string) => {
  if (!value) {
    setEmailError('Email is required');
    return false;
  }
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
    setEmailError('Invalid email format');
    return false;
  }
  setEmailError('');
  return true;
};

<input
  value={email}
  onChange={(e) => {
    setEmail(e.target.value);
    validateEmail(e.target.value);
  }}
/>
```

### 7. API Response Types
**Rule**: Always type API responses explicitly
```typescript
// ❌ BAD
const fetchUser = async (id: string) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

// ✅ GOOD
interface User {
  id: string;
  email: string;
  name: string;
}

const fetchUser = async (id: string): Promise<User> => {
  const response = await fetch(`/api/users/${id}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  return response.json();
};
```

### 8. Environment Variables
**Rule**: Always validate and provide fallbacks for env variables
```typescript
// ❌ BAD
const apiUrl = import.meta.env.VITE_API_URL;

// ✅ GOOD
const apiUrl = import.meta.env.VITE_API_URL;
if (!apiUrl) {
  throw new Error('VITE_API_URL environment variable is not defined');
}
```

### 9. Logging
**Rule**: Use centralized logging with proper context
```typescript
// ❌ BAD
console.log('Error:', error);

// ✅ GOOD
import { logError, logInfo } from '@/lib/logger';

logError('ComponentName.functionName', error, {
  userId: user.id,
  action: 'submit_form'
});
```

### 10. Date Handling
**Rule**: Always use date-fns for date operations
```typescript
// ❌ BAD
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);

// ✅ GOOD
import { addDays, format } from 'date-fns';
const tomorrow = addDays(new Date(), 1);
const formatted = format(tomorrow, 'yyyy-MM-dd');
```

## Architectural Patterns

### Single Responsibility Principle (SRP)
- Each file/module should have one clear purpose
- Components should do one thing well
- Separate business logic from UI logic

### Dependency Injection
- Pass dependencies as props/parameters
- Avoid global state when possible
- Make dependencies explicit

### Repository Pattern
- All data access through dedicated services
- Abstract away implementation details
- Consistent error handling

## Security Patterns

### 1. Never expose sensitive data
```typescript
// ❌ BAD
console.log('API Key:', apiKey);

// ✅ GOOD
console.log('API Key exists:', !!apiKey);
```

### 2. Always sanitize user input
```typescript
// ❌ BAD
const query = userInput;
supabase.rpc('search', { query });

// ✅ GOOD
const sanitizedQuery = userInput.trim().slice(0, 100);
supabase.rpc('search', { query: sanitizedQuery });
```

### 3. Use RLS for all database access
- Every table must have Row Level Security enabled
- Policies must check authentication
- Never bypass RLS in application code

## Testing Patterns

### 1. Test file naming
- `ComponentName.test.tsx` for component tests
- `utils.test.ts` for utility function tests

### 2. Test structure
```typescript
describe('ComponentName', () => {
  describe('when user is authenticated', () => {
    it('should render user dashboard', () => {
      // Test implementation
    });
  });

  describe('when user is not authenticated', () => {
    it('should redirect to login', () => {
      // Test implementation
    });
  });
});
```

## Code Review Focus Areas

1. **Error Handling**: Are all errors properly caught and logged?
2. **Type Safety**: Are all types explicitly defined?
3. **Performance**: Are there unnecessary re-renders or computations?
4. **Security**: Is user input sanitized? Are secrets protected?
5. **Accessibility**: Are ARIA labels and keyboard navigation implemented?
6. **Documentation**: Are complex functions documented?
7. **Testing**: Are critical paths covered by tests?

## Automated Checks

The following are automatically checked on commit:
- ESLint rules
- Prettier formatting
- TypeScript compilation
- Unit tests (if configured for pre-commit)

## Continuous Improvement

This document should be updated as new patterns emerge or existing ones evolve.
